// MIT/Apache2 License

use std::{
    env,
    error::Error,
    fs,
    io::prelude::*,
    path::{Path, PathBuf},
};

pub fn process_pci_ids(auto_dir: &Path) -> Result<(), Box<dyn Error>> {
    let mut pci_dir: PathBuf = env::var_os("CARGO_MANIFEST_DIR").unwrap().into();
    pci_dir.push("pci_ids");
    let pci_id_sets: Vec<PciMapping> = fs::read_dir(pci_dir)?
        .map(|f| process_pci_id(f?.path()))
        .collect::<Result<_, Box<dyn Error>>>()?;

    let mut pci_id_path = PathBuf::new();
    pci_id_path.push(auto_dir);
    pci_id_path.push("pci_ids.rs");
    let mut out = fs::File::create(pci_id_path)?;

    write!(out, "// Generated by build.rs\n")?;
    write!(out, "use std::os::raw::c_int;\n")?;

    pci_id_sets
        .into_iter()
        .for_each(|PciMapping { mut name, ids }| {
            name.make_ascii_uppercase();
            write!(out, "pub(crate) const {}: [c_int; {}] = [\n", name, ids.len()).unwrap();
            ids.into_iter().for_each(|id| {
                write!(out, "{},", id).unwrap();
            });
            write!(out, "];\n").unwrap();
        });

    Ok(())
}

struct PciMapping {
    name: String,
    ids: Vec<String>,
}

fn process_pci_id(path: PathBuf) -> Result<PciMapping, Box<dyn Error>> {
    println!("cargo:rerun-if-changed={}", path.to_str().unwrap());

    let chipsets = fs::read_to_string(&path).expect("Failed to read file to string");
    let chip_ids = chipsets
        .lines()
        .filter_map(|l| {
            if l.len() > 8 && &l[0..8] == "CHIPSET(" {
                let posn = memchr::memchr(b',', l.as_bytes())?;
                Some(l[8..posn].to_string())
            } else {
                None
            }
        })
        .collect();

    Ok(PciMapping {
        name: path.file_stem().unwrap().to_str().unwrap().to_string(),
        ids: chip_ids,
    })
}
